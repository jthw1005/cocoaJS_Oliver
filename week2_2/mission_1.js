/*
# 과제
아래와 같은 배열 모양의 문자열을 파싱한다.
이 때, 모든 숫자는 '[]'에 의해 감싸져 있다.
const data = "[1,2,[3,4,[5,[6]]]]"

# 과제 조건
0. 객체 분석 정보를 출력한다.(깊이, 원소 개수)
ex) "배열의 중첩된 깊이 수준은 4이며, 총 6개의 원소가 포함되어 있습니다."
1. 괄호의 짝이 맞지 않는 경우 오류내용을 출력한다.
ex) "닫는 괄호가 일치하지 않습니다."
2. 배열 분석 정보를 출력한다.
ex)
const data = "[1,2,[3,4,[5,[6]]]]";
run(data) >
  {
    type: "root",
    child: [
      {
        type: "array",
        child: [
          {
            type: "number",
            value: "1",
            child: [],
          },
          {
            type: "array",
            child: [
              {
                type: "number",
                value: "2",
                child: [],
              },
              {
                type: "array",
                child: [
                  {
                    type: "number",
                    value: "3",
                    child: [],
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
  };

# 힌트
0. 문제를 단순화하여 해결해본다.
1. 무한 중첩된 해법이 어렵다면, 특정한 배열문자열 형태를 처리하는 로직을 개발한다.
2. 문자열을 iteration하며 의미 있는 토큰을 추출하고 이를 분석한다.
3. 무한한 형태를 파싱할 때는, 데이터 파싱을 하는 단계에서, stack 자료 구조를 활용할 수 있다.
ex) '['을 찾은 후에 ']'를 찾을 때까지 스택자료구조를 활용하여 데이터를 모은다.

# 학습 포인트
0. 문자열을 반복문을 이용하여 파싱하는 방법을 안다.
1. 정규표현식이 무엇인지 안다.
2. stack과 queue의 차이점과 활용점을 안다.
3. 무한중첩된 구조를 재귀와 스택 자료구조를 활용하여 분석할 수 있다.

# 코드 설계
0. '['의 개수?
1. 
*/
